# -*- coding: utf-8 -*-
"""Cytof.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UHWxzzgURLFz4bM2i2xR450GZgNZU93g

# **To-Do:**


*   For Multiple Blood samples, once keep first, once latest, once nearest to LBA, once average
*   Co-expression modules
*   See which modules are enriched for each sample (t-test)
*
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.cluster.vq import whiten
from scipy.cluster.hierarchy import fcluster, linkage
from scipy.cluster.hierarchy import dendrogram
from matplotlib.ticker import MultipleLocator  # <- HERE
import pylab

def agg_merge(df):
    tf = df.reset_index().iloc[:,1:]
    row_index = [tf[x].first_valid_index() for x in tf.columns]
    row_index = [0 if x is None else x for x in row_index]
    return([tf.iloc[row_index[x],x] for x in range(0,tf.shape[1])])

"""# **New codes**

## **Cytof**
"""

df = pd.read_excel('cytof_clear.xlsx')
cytof_features = [x for x in df.columns if x.endswith('%')]
df = df[['IPP_CODED','DATE_PRELEVEMENT_CODED','CTFAN']+cytof_features]
df = df.replace(['#na','#non','Non effectué','#DIV/0!'],np.nan)
df = df.dropna(how='all', axis=0)
df = df.dropna(how='all', axis=1)
cytof_features = [x for x in df.columns if x.endswith('%')]
df = df.fillna(df.median())
df[cytof_features] = df[cytof_features].astype('float64')
df['DATE_PRELEVEMENT_CODED'] = pd.to_datetime([x for x in df['DATE_PRELEVEMENT_CODED']])
df = df.sort_values(['IPP_CODED','DATE_PRELEVEMENT_CODED'])
df

cytof_lba = df.loc[df['CTFAN']=='LBA']
cytof_lba.index = cytof_lba['IPP_CODED']
cytof_lba = cytof_lba.iloc[:,3:]
#cytof_lba.columns = [x+' LBA' for x in cytof_lba.columns]
cytof_lba

cytof_blood = df.loc[df['CTFAN']=='Blood',:]
cytof_blood = cytof_blood.drop_duplicates('IPP_CODED', keep='first')
cytof_blood.index = cytof_blood['IPP_CODED']
cytof_blood = cytof_blood.iloc[:,3:]
#cytof_blood.columns = [x+' Blood' for x in cytof_blood.columns]
cytof_blood

"""## **Toxicity**"""

toxicity = pd.read_excel('toxicity clear.xlsx')
cols = ['IPP_CODED','CTFAN','DATE_PRELEVEMENT_CODED'] + list(toxicity.columns[6:])
toxicity = toxicity[cols]
toxicity

tox_lba = toxicity.loc[toxicity['CTFAN']=='LBA']
tox_lba.index = tox_lba['IPP_CODED']
tox_lba = tox_lba.iloc[:,3:]
#tox_lba.columns = [x+' LBA' for x in tox_lba.columns]
tox_lba

tox_lba = tox_lba.loc[:,tox_lba.isna().sum()<(0.3*tox_lba.shape[0])]
tox_lba = tox_lba.fillna(tox_lba.median())
tox_lba

tox_blood = toxicity.loc[toxicity['CTFAN']=='Blood']
tox_blood = tox_blood.drop_duplicates('IPP_CODED',keep='first')
tox_blood.index = tox_blood['IPP_CODED']
tox_blood = tox_blood.iloc[:,3:]
#tox_blood.columns = [x+' Blood' for x in tox_blood.columns]
tox_blood

tox_blood = tox_blood.loc[:,tox_blood.isna().sum()<(0.3*tox_blood.shape[0])]
tox_blood = tox_blood.fillna(tox_blood.median())
tox_blood

"""## **Diagnostics**"""

diags = pd.read_excel('Diags.xlsx',sheet_name='Sheet2')
diags = diags.dropna()
diags.index = diags['IPP_CODED'].astype('str')
diags = diags.iloc[:,2:]
diags

def mapping_pres(x):
    if x == 'Infection': # or x=='Sarcoid':
        return(1)
    else:
        return(0)

def mapping_therapy(x):
    if x == 'IT':
        return(0)
    elif x == 'TKI':
        return(1)
    else:
        return(2)

def mapping_grade(x):
    if x == 'NS':
        return(0)
    else:
        return(x)

diags['Presentation_CODED'] = list(map(mapping_pres, diags['Presentation']))
diags['Therapy_CODED'] = list(map(mapping_therapy, diags['Therapy']))
diags['Grade_CODED'] = list(map(mapping_grade, diags['Grade']))

diags

"""## **Patient History**"""

def mapping_sex(x):
    if x=='M':
        return(1)
    else:
        return(0)

def mapping_resp(x):
    if x=='PNE4':
        return(0)
    elif x=='OTT1':
        return(1)
    elif x=='OSE1':
        return(2)
    elif x=='ONMH':
        return(3)

history = pd.read_excel('onco diagnostic.xlsx')
history = history[['IPP_CODED','SEXE_CODE','CODE_UF_RESP_MEDICALE']]
history = history.drop_duplicates(subset='IPP_CODED',keep='first')
history.index = history['IPP_CODED'].astype('str')
history = history.iloc[:,1:]
history['Sex_CODED'] = list(map(mapping_sex, history['SEXE_CODE']))
history['Medical Condition'] = list(map(mapping_resp, history['CODE_UF_RESP_MEDICALE']))
history

history.sum()

"""## **Previous therapies**"""

drugs = pd.read_excel('anonymized list.xlsx')
drugs.index = drugs['IPP_CODED'].astype('str')
drugs = drugs.iloc[:,1:]
drugs

"""# **Preprocessing**

## **Merging**
"""

lba_merged = pd.concat([cytof_lba,tox_lba], axis=1).dropna()
blood_merged = pd.concat([cytof_blood,tox_blood], axis=1).dropna()
df = pd.concat([lba_merged,blood_merged], axis=0)
lba_merged.columns = [x+' LBA' for x in lba_merged.columns]
blood_merged.columns = [x+' Blood' for x in blood_merged.columns]
all_merged = pd.concat([lba_merged,blood_merged],axis=1).dropna()

df['Sample'] = ['LBA']*len(lba_merged)+['Blood']*len(blood_merged)
df['Class'] = diags['Class']
ds = df.loc[:,[x for x in df.columns if x not in ['Sample','Class']]].copy()

cytof_merged = pd.concat([cytof_lba,cytof_blood], axis=1)
#cytof_merged['Sample'] = ['LBA']*len(cytof_lba)+['Blood']*len(cytof_blood)
#cytof_merged = cytof_merged.reset_index()

tox_merged = pd.concat([tox_lba,tox_blood], axis=0)
tox_merged['Sample'] = ['LBA']*len(tox_lba)+['Blood']*len(tox_blood)
tox_merged = tox_merged.reset_index()

#pd.concat([cytof_merged,tox_merged], axis=1)



"""## **Zero-variance**"""

cytof_blood = cytof_blood.loc[:,(cytof_blood.std()/cytof_blood.mean())>0.3]
cytof_lba = cytof_lba.loc[:,(cytof_lba.std()/cytof_lba.mean())>0.3]
tox_blood = tox_blood.loc[:,(tox_blood.std()/tox_blood.mean())>0.3]
tox_lba = tox_lba.loc[:,(tox_lba.std()/tox_lba.mean())>0.3]

ds = ds.loc[:,(ds.std()/ds.mean())>0.3]

lba_merged = lba_merged.loc[:,(lba_merged.std()/lba_merged.mean())>0.3]
blood_merged = blood_merged.loc[:,(blood_merged.std()/blood_merged.mean())>0.3]
all_merged = all_merged.loc[:,(all_merged.std()/all_merged.mean())>0.3]

cytof_merged = cytof_merged.loc[:,(cytof_merged.std()/cytof_merged.mean())>0.3]

"""## **Normalization**"""

#cytof_merged = (cytof_merged-cytof_merged.min())/(cytof_merged.max()-cytof_merged.min())
cytof_merged = (cytof_merged-cytof_merged.mean())/cytof_merged.std()

ds = (ds-ds.mean())/ds.std()

all_merged = (all_merged-all_merged.mean())/all_merged.std()

all_merged = (all_merged-all_merged.min())/(all_merged.max()-all_merged.min())



"""# **Single Variable**"""

from sklearn.linear_model import LogisticRegression

X = ds
y = df['Class']
clf = LogisticRegression(random_state=0).fit(X, y)
np.exp(clf.coef_)

ds_ = ds.copy()
ds_.loc['Coef',:] = np.exp(clf.coef_)
plt.figure(figsize=(22,17))
ds_.T['Coef'].sort_values(ascending=False).plot(kind='bar')
plt.xticks(fontsize=24)
plt.title('Logistic Regression Model Coefficients')
plt.savefig('svLR.png', dpi=300)

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
# import pandas_profiling
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from sklearn.feature_selection import chi2,f_classif
from sklearn.linear_model import LogisticRegressionCV
from sklearn.ensemble import RandomForestClassifier as RFC
from sklearn.ensemble import GradientBoostingClassifier as GBC

#from sklearn.metrics import plot_roc_curve
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import StratifiedKFold
import copy
import random
from sklearn.impute import SimpleImputer

import sklearn.metrics

# %matplotlib inline
# %config InlineBackend.figure_format='retina'

ds_ = ds_.iloc[:-1,:]
ds_['Class'] = df['Class']

ch_

features = [x for x in ds_.columns if x not in ['Class']]

ds__=ds_
ds__=ds__.fillna(ds__.median())
ch_ = f_classif(ds__[features], ds_['Class'],)
ch_ = np.concatenate([x[:, np.newaxis] for x in ch_], axis=1)
idx = [x for x in ds_[features].columns if x not in ['Class']]
ch_ = pd.DataFrame(ch_, index=idx, columns=['F statistic','p'])
ch_=ch_.sort_values('F statistic')
ch_['count'] = ds__.sum()
ch_['ICD10'] = ch_.index
_, subplots = plt.subplots(2,
                           1,
                           figsize=(15, 10),
                           gridspec_kw={'height_ratios': [2, 1]},
                           sharex=True)
ch_.plot.bar('ICD10',
             'F statistic',
             ax=subplots[0],
             grid=True,
             alpha=.7,
             ylabel='F statistic',
             logy=True)
ax = plt.twinx(subplots[0])
ch_.plot.scatter('ICD10', 'p', ax=ax, logy=True, color='red')
# ax.set_ylim(1e-34,1)
ax.grid(axis='y', linestyle=':')
ch_.plot.bar('ICD10', 'count', ax=subplots[1], logy=True, grid=True)
subplots[-1].set_xlabel('ICD10')
plt.suptitle('Fisher Exact Test Between Presentation Groups')

plt.tight_layout()
plt.savefig('svFtest.png',dpi=300)

ds_['Class'] = df['Class']

df

df.to_csv('datacytof.csv')

"""# **Clustering**"""

import scipy
import scipy.cluster.hierarchy as sch

def cluster_corr(corr_array, inplace=False):
    """
    Rearranges the correlation matrix, corr_array, so that groups of highly
    correlated variables are next to eachother

    Parameters
    ----------
    corr_array : pandas.DataFrame or numpy.ndarray
        a NxN correlation matrix

    Returns
    -------
    pandas.DataFrame or numpy.ndarray
        a NxN correlation matrix with the columns and rows rearranged
    """
    pairwise_distances = sch.distance.pdist(corr_array)
    linkage = sch.linkage(pairwise_distances, method='complete')
    cluster_distance_threshold = pairwise_distances.max()/2
    idx_to_cluster_array = sch.fcluster(linkage, cluster_distance_threshold,
                                        criterion='distance')
    idx = np.argsort(idx_to_cluster_array)

    if not inplace:
        corr_array = corr_array.copy()

    if isinstance(corr_array, pd.DataFrame):
        return corr_array.iloc[idx, :].T.iloc[idx, :], idx_to_cluster_array
    return corr_array[idx, :][:, idx], idx_to_cluster_array

"""## **Culstering samples**"""

pairwise_distances = sch.distance.pdist(ds)
linkage = sch.linkage(pairwise_distances, method='complete')
cluster_distance_threshold = pairwise_distances.max()/2
idx_to_cluster_array = sch.fcluster(linkage, t=cluster_distance_threshold,criterion='distance')
print(np.sort(idx_to_cluster_array))
print(np.argsort(idx_to_cluster_array))
ds.index[np.argsort(idx_to_cluster_array)]

from sklearn.decomposition import PCA

# Initialize PCA
pca = PCA(n_components=2)

# Apply PCA to your features
pca_result = pca.fit_transform(ds)

colors = df['Class']
# Visualize the reduced data
plt.figure(figsize=(20,20))
plt.scatter(pca_result[:, 0], pca_result[:, 1], c=colors)
plt.title("PCA Visualization")
plt.xlabel("Principal Component 1")
plt.ylabel("Principal Component 2")
plt.colorbar(label="Diagnosis")
n = ds.index
for i, txt in enumerate(n):
    plt.annotate(txt[-4:], (pca_result[i, 0], pca_result[i, 1]))
plt.show()

"""## **Cytof merge**"""

np.sort(idx)

corrmat = ds.corr().dropna(axis=0, how='all').dropna(axis=1)
cluster_mat, idx = cluster_corr(corrmat)
alpha = [x for x in cluster_mat.columns]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(cluster_mat, interpolation='nearest', cmap=plt.cm.Spectral_r)
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+alpha)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE
plt.savefig('CorrelationMap.png', dpi=300)
plt.show()



corrmat = all_merged.corr().dropna(axis=0, how='all').dropna(axis=1)
cluster_mat, idx = cluster_corr(corrmat)
alpha = [x for x in cluster_mat.columns]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(cluster_mat, interpolation='nearest', cmap=plt.cm.Spectral_r)
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+alpha)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.savefig('AllMerged.png', dpi=300)
plt.show()

np.unique(idx)

cluster_score =pd.DataFrame(index=ds.index, columns=['C'+str(x) for x in np.unique(idx)])
cluster_score

for clust in np.unique(idx):
    cluster_score['C'+str(clust)] = ds.loc[:,[ds.columns[x] for x in np.argsort(idx) if idx[x]==clust]].sum(axis=1)

cluster_score

df.loc[cluster_score.index,'Class'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Class']

cluster_score['Class'] = df.loc[cluster_score.index,'Class'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Class']

cluster_score.to_csv('cluster_score_presentation.csv')

corrmat = lba_merged.corr().dropna(axis=0, how='all').dropna(axis=1)
alpha = [x for x in cluster_corr(corrmat).columns]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(cluster_corr(corrmat), interpolation='nearest', cmap=plt.cm.Spectral_r)
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+alpha)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.show()

corrmat = blood_merged.corr().dropna(axis=0, how='all').dropna(axis=1)
alpha = [x for x in cluster_corr(corrmat).columns]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(cluster_corr(corrmat), interpolation='nearest', cmap=plt.cm.Spectral_r)
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+alpha)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.show()

cytof_merged

corrmat = cytof_merged.loc[:,[x for x in cytof_merged.columns if x not in ['IPP_CODED','Sample']]].corr().dropna(axis=0, how='all').dropna(axis=1)
alpha = [x for x in cluster_corr(corrmat)[0].columns]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(cluster_corr(corrmat)[0], interpolation='nearest', cmap=plt.cm.Spectral_r)
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+alpha)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.show()

corrmat = pd.concat([cytof_blood,tox_blood], axis=1).corr().dropna(axis=0, how='all').dropna(axis=1)
alpha = [x[:-6] for x in cluster_corr(corrmat).columns]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(cluster_corr(corrmat), interpolation='nearest')
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+alpha)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.show()





"""# **Correlation**"""

lba = pd.concat([tox_blood,tox_lba], axis=1).dropna()
plt.matshow(cluster_corr(lba.corr()))

corrmat = pd.concat([cytof_lba,cytof_blood], axis=1).dropna().corr()
between_cytof = corrmat.loc[[x for x in corrmat.index if x.endswith('LBA')],
                            [x for x in corrmat.columns if x.endswith('Blood')]]
between_cytof = between_cytof.loc[[x for x in between_cytof.index if x not in ['CD141+ DCELLS % LBA']]].dropna(axis=1)
plt.matshow(cluster_corr(between_cytof))

merge_tox = pd.concat([tox_lba,tox_blood], axis=1).dropna()
merge_tox = merge_tox.loc[:,(merge_tox.std()/merge_tox.mean())>0.3]
corrmat = merge_tox.corr()
between_tox = corrmat.loc[[x for x in corrmat.index if x.endswith('LBA')],
                          [x for x in corrmat.columns if x.endswith('Blood')]]
#between_tox = between_tox.loc[[x for x in between_tox.index if x not in ['CD141+ DCELLS % LBA']]].dropna(axis=1)
plt.matshow(cluster_corr(between_tox))

tox_blood = toxicity.loc[toxicity['CTFAN']=='Blood',:]
tox_features = ['IPP_CODED','DATE_RECEPTION_CODED','CTFAN']+[x for x in tox_blood.columns[5:-1]]
tox_blood = tox_blood[tox_features]
tox_blood = tox_blood.dropna(how='all', axis=0)
tox_blood = tox_blood.dropna(how='all', axis=1)

for ipp in tox_blood['IPP_CODED'].unique():
    tox_blood.loc[ipp,:] = agg_merge(tox_blood.loc[tox_blood['IPP_CODED']==ipp,:])

tox_blood = tox_blood.loc[tox_blood['IPP_CODED'].unique(),:]

for col in tox_blood.columns:
    #if tox_blood[col].isna().sum()/tox_blood.shape[0] > 0.5:
    #    tox_blood = tox_blood.drop(col, axis=1)
    #    continue
    try:
        tox_blood.loc[tox_blood[col].str.startswith('<')==True,col] = '1'
    except AttributeError:
        continue

tox_blood = tox_blood.fillna('1')
tox_features = [x for x in tox_blood.columns[3:]]
tox_blood[tox_features] = tox_blood[tox_features].astype('float64')
tox_highvar_blood = [x for x in tox_features if tox_blood[x].var()>0]
tox_blood = tox_blood[['IPP_CODED','DATE_RECEPTION_CODED','CTFAN']+tox_highvar_blood]
tox_blood = tox_blood.iloc[:,3:]
tox_blood



"""# **Enriched Cluster**"""

clusters = []
for i in range(1,np.max(idx)+1):
    clusters.append([ds.columns[x] for x in np.argsort(idx) if idx[x]==i])

clusters

diags.loc[corrmat.columns,:]

history.loc[[x for x in corrmat.columns if x in history.index],'Medical Condition']

drugs

history.loc[[x for x in corrmat.columns if x in history.index],'Sex_CODED'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Sex_CODED']

corrmat = (ds.loc[:,[x for x in clusters[1]+clusters[4] if x.endswith('%') or x.startswith('I')]]).T
corrmat_meta = corrmat.copy()
corrmat_meta.loc['Sample',:] = [0]*len(lba_merged)+[1]*len(blood_merged)
corrmat_meta.loc['Presentation',:] = diags.loc[corrmat.columns,'Presentation_CODED']
corrmat_meta.loc['Therapy',:] = diags.loc[corrmat.columns,'Therapy_CODED']
corrmat_meta.loc['Grade',:] = diags.loc[corrmat.columns,'Grade_CODED']
corrmat_meta.loc['Sex',:] = history.loc[[x for x in corrmat.columns if x in history.index],'Sex_CODED'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Sex_CODED']
corrmat_meta.loc['Medical Condition',:] = history.loc[[x for x in corrmat.columns if x in history.index],'Medical Condition'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Medical Condition']
corrmat_meta.loc['Pembrolizumab',:] = drugs.loc[[x for x in corrmat.columns if x in drugs.index],'Pembrolizumab'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Pembrolizumab']
corrmat_meta.loc['Durvalumab',:] = drugs.loc[[x for x in corrmat.columns if x in drugs.index],'Durvalumab'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Durvalumab']
corrmat_meta.loc['Nivolumab',:] = drugs.loc[[x for x in corrmat.columns if x in drugs.index],'Nivolumab'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Nivolumab']
corrmat_meta.loc['Ipilimumab',:] = drugs.loc[[x for x in corrmat.columns if x in drugs.index],'Ipilimumab'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Ipilimumab']
corrmat_meta.loc['Atezolizumab',:] = drugs.loc[[x for x in corrmat.columns if x in drugs.index],'Atezolizumab'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['Atezolizumab']
#corrmet_meta.loc['steroid therapy',:] = drugs.loc[[x for x in corrmat.columns if x in drugs.index],'steroid therapy'].reset_index().drop_duplicates(subset='IPP_CODED').set_index('IPP_CODED')['steroid therapy']
corrmat_meta = corrmat_meta.fillna(0)

pairwise_distances = sch.distance.pdist(corrmat.T)
linkage = sch.linkage(pairwise_distances, method='complete')
cluster_distance_threshold = pairwise_distances.max()/2
idx_to_cluster_array = sch.fcluster(linkage, t=cluster_distance_threshold,criterion='distance')
print(np.sort(idx_to_cluster_array))
print(np.argsort(idx_to_cluster_array))
corrmat = corrmat.iloc[:,np.argsort(idx_to_cluster_array)]
corrmat_meta = corrmat_meta.iloc[:,np.argsort(idx_to_cluster_array)]

corrmat_meta_only = corrmat_meta.copy().loc[[x for x in corrmet_meta.index if x not in corrmat.index],:]
corrmat_meta_history = corrmat_meta_only.iloc[:6,:]
corrmat_meta_drugs = corrmat_meta_only.iloc[6:,:]
corrmat_meta_history

alpha = [x for x in corrmat_meta_drugs.columns]
beta = [y for y in corrmat_meta_drugs.index]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(corrmat_meta_drugs, interpolation='nearest', cmap=plt.cm.binary)
fig.colorbar(cax)

#ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+beta)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
#ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.savefig('ConfoundingDrug.png', dpi=300)
plt.show()

alpha = [x for x in corrmat_meta_history.columns]
beta = [y for y in corrmat_meta_history.index]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(corrmat_meta_history, interpolation='nearest', cmap=plt.cm.PRGn)

fig.colorbar(cax)

ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+beta)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.savefig('ConfoundingHistory.png', dpi=300)
plt.show()

alpha = [x for x in corrmat.columns]
beta = [y for y in corrmat.index]
fig = plt.figure(figsize=(20,20))
ax = fig.add_subplot(111)
cax = ax.matshow(corrmat, interpolation='nearest', cmap=plt.cm.bwr)
fig.colorbar(cax)

ax.set_xticklabels(['']+alpha, rotation=90)
ax.set_yticklabels(['']+beta)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE

plt.savefig('EnrichedClusters.png', dpi=300)
plt.show()

df.plot(x='Class', y=clusters[0], kind='bar')

np.argsort(idx)

ds.iloc[:,np.argsort(idx)].to_csv('dfCYTOFsorted.csv')

df_ = df.loc[:,[x for x in df.columns if x not in ['Sample','Class']]].copy()
df_ = df_.loc[:,(df_.std()/df_.mean())>0.3]
df_ = df_.iloc[:,np.argsort(idx)]

df_.to_csv('dfCYTOFsorted.csv')

df_.columns

df.to_csv('dataframeCYTOF.csv')

"""# **Analysis**"""



idx = []
for ipp in cytof_lba['IPP_CODED'].unique():
    blood_tests = cytof_blood.loc[cytof_blood['IPP_CODED']==ipp,:]
    mask = blood_tests['DATE_RECEPTION_CODED'] > cytof_lba.loc[cytof_lba['IPP_CODED']==ipp,'DATE_RECEPTION_CODED'].iloc[0]
    if mask.shape[0] == 0:
        continue
    if mask.sum() == 0:
        idx.append(mask.index[-1])
    if mask.sum() > 0:
        idx.append(mask.idxmax())

cytof_blood_ = cytof_blood.loc[idx,:].sort_values('IPP_CODED')

cytof_blood_.index = cytof_blood_['IPP_CODED']
cytof_lba_ = cytof_lba.loc[cytof_lba['IPP_CODED'].isin(cytof_blood.loc[idx,'IPP_CODED']),:].sort_values('IPP_CODED')
cytof_lba_.index = cytof_lba_['IPP_CODED']

#cytof_lba_[cytof_features] = (cytof_lba_[cytof_features]-cytof_lba_[cytof_features].mean())/cytof_lba_[cytof_features].std()
#cytof_blood_[cytof_features] = (cytof_blood_[cytof_features]-cytof_blood_[cytof_features].mean())/cytof_blood_[cytof_features].std()

cytof_lba_[cytof_features] = (cytof_lba_[cytof_features]-cytof_lba_[cytof_features].min())/(cytof_lba_[cytof_features].max()-cytof_lba_[cytof_features].min())
cytof_blood_[cytof_features] = (cytof_blood_[cytof_features]-cytof_blood_[cytof_features].min())/(cytof_blood_[cytof_features].max()-cytof_blood_[cytof_features].min())

distance_matrix = linkage(cytof_lba_[cytof_features].T, method = 'ward', metric = 'euclidean', optimal_ordering=True)
dn = dendrogram(distance_matrix)
plt.show()

sorted_cytof_features = [cytof_lba_[cytof_features].columns[x] for x in dn['leaves']]

cytof_blood_clust = cytof_blood_[sorted_cytof_features]
cytof_lba_clust = cytof_lba_[sorted_cytof_features]

cytof_corr = pd.DataFrame(data=None, index=[x+' LBA' for x in sorted_cytof_features], columns=[x+' Blood' for x in sorted_cytof_features])
for col in sorted_cytof_features:
    cytof_corr[col+' Blood'] = list(cytof_blood_clust.corrwith(cytof_lba_clust[col]))
cytof_corr = cytof_corr.dropna(how='all', axis=1)
cytof_corr = cytof_corr.dropna(how='all', axis=0)
cytof_corr

from matplotlib.ticker import MultipleLocator  # <- HERE

x_labels = list(cytof_corr.columns)
y_labels = list(cytof_corr.index)

data = cytof_corr

fig = plt.figure(figsize=(25,25))
ax = fig.add_subplot(111)
cax = ax.matshow(cytof_corr, interpolation='nearest')
fig.colorbar(cax)

ax.set_xticklabels(x_labels)
ax.set_yticklabels(y_labels)
ax.yaxis.set_major_locator(MultipleLocator(1))  # <- HERE
ax.xaxis.set_major_locator(MultipleLocator(1))  # <- HERE
plt.xticks(rotation=45, ha='left')

plt.savefig('Cytof_Correlation.png', dpi=300)
plt.show()

import pylab

cytof_corr

# Compute and plot first dendrogram.
fig = plt.figure(figsize=(15, 15))
ax1 = fig.add_axes([0.09, 0.1, 0.2, 0.6])
Y = linkage(cytof_lba_clust.T, method='ward')
Z1 = dendrogram(Y, orientation='left')
ax1.set_xticks([])
ax1.set_yticks([])

# Compute and plot second dendrogram.
ax2 = fig.add_axes([0.3, 0.72, 0.6, 0.2])
Y = linkage(cytof_blood_clust.dropna(how='all',axis=1).T, method='ward')
Z2 = dendrogram(Y)
ax2.set_xticks([])
ax2.set_yticks([])

# Plot distance matrix.
axmatrix = fig.add_axes([0.3, 0.1, 0.6, 0.6])
idx1 = [cytof_lba_clust.columns[x]+' LBA' for x in Z1['leaves']]
idx2 = [cytof_blood_clust.columns[x]+' Blood' for x in Z2['leaves']]

cytof_corr = cytof_corr.loc[:,idx2]
cytof_corr = cytof_corr.loc[idx1[:-1],:]

im = axmatrix.matshow(cytof_corr.dropna(), aspect='auto', cmap=plt.cm.viridis)
axmatrix.set_xticks([])  # remove axis labels
axmatrix.set_yticks([])  # remove axis labels

axmatrix.set_xticks(range(len(idx1[:-1])))
axmatrix.set_xticklabels(idx1[:-1], minor=False)
axmatrix.xaxis.set_label_position('bottom')
axmatrix.xaxis.tick_bottom()

pylab.xticks(rotation=-90, fontsize=9)

axmatrix.set_yticks(range(len(idx2)))
axmatrix.set_yticklabels(idx2, minor=False)
axmatrix.yaxis.set_label_position('right')
axmatrix.yaxis.tick_right()

axcolor = fig.add_axes([1.05, 0.1, 0.02, 0.6])
plt.colorbar(im, cax=axcolor)
axmatrix.set_title('Immune Cells Relative Abundance Correlation in LBA and Blood')

plt.savefig('Cytof_Correlation.png', dpi=300)
plt.show()

tox_lba['IL_1RA_LIQ_BIOL_58'] = tox_lba['IL_1RA_LIQ_BIOL_58']/1000
tox_lba[tox_highvar] = (tox_lba[tox_highvar]-tox_lba[tox_highvar].min())/(tox_lba[tox_highvar].max()-tox_lba[tox_highvar].min())

cytof_lba_ = cytof_lba.loc[cytof_lba['IPP_CODED'].isin(tox_lba.index)]
cytof_lba_.index = cytof_lba_['IPP_CODED']
corrmat = pd.DataFrame(data=None, index=cytof_features, columns=tox_highvar)
corrmat

for col in tox_highvar:
    corrmat[col] = list(cytof_lba_[cytof_features].corrwith(tox_lba[col]))

corrmat

# Compute and plot first dendrogram.
fig = plt.figure(figsize=(14, 10))
ax1 = fig.add_axes([0.09, 0.1, 0.2, 0.6])
Y = linkage(cytof_lba_[cytof_features].T, method='ward')
Z1 = dendrogram(Y, orientation='left')
ax1.set_xticks([])
ax1.set_yticks([])

# Compute and plot second dendrogram.
ax2 = fig.add_axes([0.3, 0.72, 0.6, 0.2])
Y = linkage(tox_lba[tox_highvar].T, method='ward')
Z2 = dendrogram(Y)
ax2.set_xticks([])
ax2.set_yticks([])

# Plot distance matrix.
axmatrix = fig.add_axes([0.3, 0.1, 0.6, 0.6])
idx1 = [cytof_lba_[cytof_features].columns[x] for x in Z1['leaves']]
idx2 = [tox_lba[tox_highvar].columns[x] for x in Z2['leaves']]

corrmat = corrmat.loc[:,idx2]
corrmat = corrmat.loc[idx1[:-1],:]

im = axmatrix.matshow(corrmat, aspect='auto', cmap=plt.cm.viridis)
axmatrix.set_xticks([])  # remove axis labels
axmatrix.set_yticks([])  # remove axis labels

axmatrix.set_xticks(range(len(idx2)))
axmatrix.set_xticklabels(idx2, minor=False)
axmatrix.xaxis.set_label_position('bottom')
axmatrix.xaxis.tick_bottom()

pylab.xticks(rotation=-90, fontsize=9)

axmatrix.set_yticks(range(len(idx1)))
axmatrix.set_yticklabels(idx1, minor=False)
axmatrix.yaxis.set_label_position('right')
axmatrix.yaxis.tick_right()

axcolor = fig.add_axes([1.05, 0.1, 0.02, 0.6])
plt.colorbar(im, cax=axcolor)
axmatrix.set_title('Immune Cells and Cytokines in LBA Correlation')

plt.savefig('LBA_Correlation.png', dpi=300)
plt.show()



tox_blood[tox_highvar] = (tox_blood[tox_highvar]-tox_blood[tox_highvar].min())/(tox_blood[tox_highvar].max()-tox_blood[tox_highvar].min())

cytof_blood_ = cytof_blood.loc[cytof_blood['IPP_CODED'].isin(tox_blood.index)]
cytof_blood_.index = cytof_blood_['IPP_CODED']
corrmat = pd.DataFrame(data=None, index=cytof_features, columns=tox_highvar)
corrmat

for col in tox_highvar:
    corrmat[col] = list(cytof_blood_[cytof_features].corrwith(tox_blood[col]))

corrmat



# Compute and plot first dendrogram.
fig = plt.figure(figsize=(14, 10))
ax1 = fig.add_axes([0.09, 0.1, 0.2, 0.6])
Y = linkage(cytof_blood_[cytof_features].T, method='ward')
Z1 = dendrogram(Y, orientation='left')
ax1.set_xticks([])
ax1.set_yticks([])

# Compute and plot second dendrogram.
ax2 = fig.add_axes([0.3, 0.72, 0.6, 0.2])
Y = linkage(tox_blood[tox_highvar].T, method='ward')
Z2 = dendrogram(Y)
ax2.set_xticks([])
ax2.set_yticks([])

# Plot distance matrix.
axmatrix = fig.add_axes([0.3, 0.1, 0.6, 0.6])
idx1 = [cytof_blood_[cytof_features].columns[x] for x in Z1['leaves']]
idx2 = [tox_blood[tox_highvar].columns[x] for x in Z2['leaves']]

corrmat = corrmat.loc[:,idx2]
corrmat = corrmat.loc[idx1[:-1],:]

im = axmatrix.matshow(corrmat, aspect='auto', cmap=plt.cm.viridis)
axmatrix.set_xticks([])  # remove axis labels
axmatrix.set_yticks([])  # remove axis labels

axmatrix.set_xticks(range(len(idx2)))
axmatrix.set_xticklabels(idx2, minor=False)
axmatrix.xaxis.set_label_position('bottom')
axmatrix.xaxis.tick_bottom()

pylab.xticks(rotation=-90, fontsize=9)

axmatrix.set_yticks(range(len(idx1)))
axmatrix.set_yticklabels(idx1, minor=False)
axmatrix.yaxis.set_label_position('right')
axmatrix.yaxis.tick_right()

axcolor = fig.add_axes([1.05, 0.1, 0.02, 0.6])
plt.colorbar(im, cax=axcolor)
axmatrix.set_title('Immune Cells and Cytokines in Blood Correlation')

plt.savefig('Blood_Correlation.png', dpi=300)
plt.show()

tox_blood_ = tox_blood[tox_highvar_blood]
tox_lba_ = tox_lba[tox_highvar_lba]
tox_blood

tox_corr = pd.DataFrame(data=None, index=[x+ ' LBA' for x in tox_lba_], columns=[x+' Blood' for x in tox_blood_])
tox_corr

for col in tox_corr.columns:
    tox_corr[col] = list(tox_lba_.corrwith(tox_blood_[col[:-6]]))

tox_corr = tox_corr.dropna(how='all', axis=1)
tox_corr = tox_corr.dropna(how='all', axis=0)
tox_corr = tox_corr.drop()

tox_corr

# Compute and plot first dendrogram.
fig = plt.figure(figsize=(14, 10))
ax1 = fig.add_axes([0.09, 0.1, 0.2, 0.6])
Y = linkage(tox_blood_.T, method='ward')
Z1 = dendrogram(Y, orientation='left')
ax1.set_xticks([])
ax1.set_yticks([])

# Compute and plot second dendrogram.
ax2 = fig.add_axes([0.3, 0.72, 0.6, 0.2])
Y = linkage(tox_lba_.T, method='ward')
Z2 = dendrogram(Y)
ax2.set_xticks([])
ax2.set_yticks([])

# Plot distance matrix.
axmatrix = fig.add_axes([0.3, 0.1, 0.6, 0.6])
idx1 = [tox_blood_.columns[x]+' Blood' for x in Z1['leaves']]
idx2 = [tox_lba_.columns[x]+' LBA' for x in Z2['leaves']]
idx2 = [x for x in idx2 if x in tox_corr.index]

tox_corr = tox_corr.loc[:,idx1]
tox_corr = tox_corr.loc[idx2,:]

im = axmatrix.matshow(tox_corr.T, aspect='auto', cmap=plt.cm.viridis)
axmatrix.set_xticks([])  # remove axis labels
axmatrix.set_yticks([])  # remove axis labels

axmatrix.set_xticks(range(len(idx2)))
axmatrix.set_xticklabels(idx2, minor=False)
axmatrix.xaxis.set_label_position('bottom')
axmatrix.xaxis.tick_bottom()

pylab.xticks(rotation=-90, fontsize=9)

axmatrix.set_yticks(range(len(idx1)))
axmatrix.set_yticklabels(idx1, minor=False)
axmatrix.yaxis.set_label_position('right')
axmatrix.yaxis.tick_right()

axcolor = fig.add_axes([1.05, 0.1, 0.02, 0.6])
plt.colorbar(im, cax=axcolor)
axmatrix.set_title('Cytokines in Blood and LBA Correlation')

plt.savefig('Toxicity_Correlation.png', dpi=300)
plt.show()

tox_corr

"""# **New Diags**"""

diag = pd.read_excel('anonymized list.xlsx')
diag = diag.loc[diag['IPP_CODED'].isna()==False,:]
diag.index = diag['IPP_CODED']
diag = diag.iloc[:,3:]
diag['Grade'] = diag['Grade'].fillna(0)
diag[['steroid therapy','response to therapy']] = diag[['steroid therapy','response to therapy']].fillna('N')
diag.loc[diag['steroid therapy']=='N','steroid therapy'] = 0
diag.loc[diag['steroid therapy']=='Y','steroid therapy'] = 1
diag.loc[diag['response to therapy']=='N','response to therapy'] = 0
diag.loc[diag['response to therapy']=='Y','response to therapy'] = 1
diag.loc[diag['Label']=='COP','Label'] = 0
diag.loc[diag['Label']=='ILD','Label'] = 1
diag.loc[diag['Label']=='Sarcoid','Label'] = 2
diag.loc[diag['Label']=='Infection','Label'] = 3
diag = diag.iloc[:,:-1]
diag.loc[diag['Label']==2,'Class'] = 1
diag.loc[diag['Label']!=2,'Class'] = 0
diag = diag.astype('float64')
diag



"""# **Diagnostics**"""



diag2 = pd.read_excel('Diags.xlsx', sheet_name='Sheet2')
diag2 = diag2.loc[diag2['IPP_CODED'].isna()==False,:]
diag2.index = diag2['IPP_CODED']
diag2.loc[diag2['Label']=='Not Sarcoid','Label'] = 0
diag2.loc[diag2['Label']=='Sarcoid','Label'] = 1
diag2

"""# **Cytof**"""

cytof = pd.read_excel('cytof.xlsx')

"""Sample Dates"""

t = cytof['COMMENTAIRE'].str.contains('broncho').fillna(False)
broncho_dates = cytof.iloc[[i-1 for i,x in enumerate(t) if x],4].copy()
#broncho_dates = pd.to_datetime([x[:10] for x in broncho_dates])

"""Broncho"""

lba = cytof.iloc[[i-1 for i,x in enumerate(t) if x],:].copy()
lba.index = lba['IPP_CODED']
lba = lba.iloc[:,7:-2]
lba = lba.loc[:,[x for x in lba.columns if x.endswith('%')]]
lba = lba.replace(['#na','#non','Non effectué','#DIV/0!'],np.nan)
lba = lba.dropna(axis=0, how='all')
lba = lba.dropna(axis=1, how='all')
lba = lba.fillna(lba.median())
lba = lba.astype('float64')
lba

"""Blood"""

blood = cytof.iloc[[i-1 for i,x in enumerate(t) if x],:].copy()
blood.index = blood['IPP_CODED']

for x in range(0,len(broncho_dates)):
    ipp = cytof.loc[broncho_dates.index[x],:]['IPP_CODED']
    subset = cytof.loc[cytof['IPP_CODED']==ipp,:]
    subset['DATE_RECEPTION_CODED'] = pd.to_datetime(subset['DATE_RECEPTION_CODED'])
    subset = subset.sort_values(['DATE_RECEPTION_CODED'])
    mask = pd.to_datetime(subset['DATE_RECEPTION_CODED'])>pd.to_datetime(broncho_dates.iloc[x])
    subset = subset.loc[mask]
    if subset.shape[0]==0:
        blood = blood.drop(ipp, axis=0)
        continue
    blood.loc[ipp,:] = agg_merge(subset)
blood = blood.loc[:,[x for x in blood.columns if x.endswith('%')]]
blood = blood.replace(['#na','#non','Non effectué','#DIV/0!'],np.nan)
blood = blood.dropna(axis=0, how='all')
blood = blood.dropna(axis=1, how='all')
blood = blood.fillna(blood.median())
blood = blood.astype('float64')
blood

blood

"""# **Old Cytof Codes**"""

cytof = pd.read_excel('cytof.xlsx')
#cytof = cytof.drop_duplicates('DATE_RECEPTION_CODED',keep='first').drop_duplicates('IPP_CODED',keep='last')
#cytof.index = cytof.iloc[:,0]
#cytof = cytof.iloc[:,6:-2]
#cytof = cytof.replace(['#na','#non','Non effectué','#DIV/0!'],np.nan)
#cytof = cytof.dropna(axis=1,how='all')
#cytof = cytof.dropna(axis=0,how='all')
#cytof = cytof.astype('float64')
cytof

"""NA Imputation"""

cytof.loc[:,'LYMPHO. TOTAUX'] = cytof.loc[:,'LYMPHO. TOTAUX'].fillna(cytof.loc[:,'LYMPHO. TOTAUX'].median())

abs_cols = [x for x in cytof.columns if not x.endswith('%')]
rel_cols = [x for x in cytof.columns if x.endswith('%')]
df = (cytof[rel_cols].mul(cytof['LYMPHO. TOTAUX'], axis=0)/100).round(0)
#df['LYMPHO. TOTAUX'] = cytof['LYMPHO. TOTAUX']

df.columns = [x[:-1] for x in rel_cols]

"""# **Toxicity**"""

toxicity = pd.read_excel('toxicity lab data extraction 1.xlsx')
toxicity_agg = toxicity.drop_duplicates('IPP_CODED',keep = 'last')
toxicity_agg.index = toxicity_agg['IPP_CODED']
#toxicity = toxicity.loc[:,['IPP_CODED']+list(toxicity.columns[5:])]
#toxicity_agg = toxicity_agg.loc[:,['IPP_CODED']+list(toxicity_agg.columns[5:])]
#toxicity = toxicity.loc[toxicity['DATE_RECEPTION_CODED'].isin(broncho_dates),:]
#toxicity.index = toxicity['IPP_CODED']
#toxicity = toxicity.iloc[:,5:]
toxicity



IPPs = toxicity['IPP_CODED'].unique()

"""LBA Toxicity"""

lba_tox = toxicity.loc[toxicity['DATE_RECEPTION_CODED'].isin(broncho_dates),:]
lba_tox

IPPs = lba_tox['IPP_CODED'].unique()
for ipp in IPPs:
    subset = lba_tox.loc[lba_tox['IPP_CODED']==ipp,:].copy().reset_index().iloc[:,1:]
    lba_tox.loc[ipp,:] = agg_merge(subset)
lba_tox_agg = lba_tox.loc[IPPs]
lba_tox_agg = lba_tox_agg.iloc[:,5:]
lba_tox_agg

toxicity_agg = lba_tox_agg.copy()

for col in toxicity_agg.columns:
    if (toxicity_agg[col].isna().sum())/toxicity_agg.shape[0] > 0.7:
        toxicity_agg = toxicity_agg.drop(col, axis=1)
    try:
        mask = toxicity_agg[col].str.startswith('<')
    except:
        continue
    mask = mask.fillna(False)
    toxicity_agg.loc[mask,col] = 1
    toxicity_agg[col] = toxicity_agg[col].astype('float64')
toxicity_agg = toxicity_agg.fillna(toxicity_agg.median())
toxicity_agg = toxicity_agg.astype('float64')
toxicity_agg



"""Blood Toxicity"""

blood_tox = toxicity.iloc[[i-1 for i,x in enumerate(t) if x],:].copy()
IPPs = blood_tox['IPP_CODED'].unique()
for ipp in IPPs:
    subset = blood_tox.loc[blood_tox['IPP_CODED']==ipp,:].copy().reset_index().iloc[:,1:]
    blood_tox.loc[ipp,:] = agg_merge(subset)
blood_tox_agg = blood_tox.loc[IPPs]
blood_tox_agg = blood_tox_agg.iloc[:,5:]
blood_tox_agg

plt.plot(blood_tox_agg.isna().sum())

for col in blood_tox_agg.columns:
    if (blood_tox_agg[col].isna().sum())/blood_tox_agg.shape[0] > 0.7:
        blood_tox_agg = blood_tox_agg.drop(col, axis=1)
    try:
        mask = blood_tox_agg[col].str.startswith('<')
    except:
        continue
    mask = mask.fillna(False)
    blood_tox_agg.loc[mask,col] = 1
    blood_tox_agg[col] = blood_tox_agg[col].astype('float64')
blood_tox_agg = blood_tox_agg.fillna(blood_tox_agg.median())
blood_tox_agg = blood_tox_agg.astype('float64')
blood_tox_agg



"""## **Blood - Lung Cytof Correlation**"""

plt.scatter(lba_subset.loc[:,'CD4 PD-1 %'], blood.loc[:,'LYMPHO TFH %'])
#plt.scatter(lba_subset.iloc[:,1], blood.iloc[:,1], label=lba_subset.columns[1])
#plt.scatter(lba_subset.iloc[:,2], blood.iloc[:,2], label=lba_subset.columns[2])

plt.legend()

lba_subset = lba.loc[lba.index.isin(blood.index)]

cytof_corr = pd.DataFrame(data=None, index=[x+' LBA' for x in lba_subset.columns], columns=[x+' Blood' for x in blood.columns])

for col in cytof_corr.columns:
    cytof_corr[col] = list(lba_subset.corrwith(blood[col[:-6]]))

cytof_corr.iloc[8:13,10:15]

plt.matshow(cytof_corr)

toxic_corr = pd.DataFrame(data=None, index=[x+' LBA' for x in toxicity_agg.columns], columns=[x+' Blood' for x in blood_tox_agg.columns])
toxic_corr

for col in toxic_corr.columns:
    toxic_corr[col] = list(toxicity_agg.corrwith(blood_tox_agg[col[:-6]]))

toxic_corr

plt.matshow(toxic_corr)

lba_new = lba.loc[lba.index.isin(blood_new.index),:]
lba_new = lba_new.fillna(lba_new.median())



plt.matshow(lba_new.corr())
plt.legend()

lba

for x in range(0,len(broncho_dates)):
    ipp = toxicity.loc[broncho_dates.index[x],:]['IPP_CODED']
    subset = toxicity.loc[toxicity['IPP_CODED']==ipp,:]
    subset['DATE_RECEPTION_CODED'] = pd.to_datetime(subset['DATE_RECEPTION_CODED'])
    subset = subset.sort_values(['DATE_RECEPTION_CODED'])
    mask = pd.to_datetime(subset['DATE_RECEPTION_CODED'])>pd.to_datetime(broncho_dates.iloc[x])
    subset = subset.loc[mask]
    if subset.shape[0]==0:
        blood_tox = blood_tox.drop(ipp, axis=0)
        continue
    blood_tox.loc[ipp,:] = agg_merge(subset)
blood_tox = blood_tox.loc[:,[x for x in blood_tox.columns if x.endswith('%')]]
blood_tox = blood_tox.replace(['#na','#non','Non effectué','#DIV/0!'],np.nan)
blood_tox = blood_tox.dropna(axis=0, how='all')
blood_tox = blood_tox.dropna(axis=1, how='all')
blood_tox = blood_tox.fillna(blood.median())
blood_tox = blood_tox.astype('float64')
blood_tox



"""# **Old Toxic Codes**"""

toxicity = pd.read_excel('toxicity lab data extraction 1.xlsx')

toxicity_ctfan = [df.loc[df['DATE_RECEPTION_CODED']==x,'CTFAN'].iloc[0] if not df.loc[df['DATE_RECEPTION_CODED']==x,'CTFAN'].shape[0]==0 else 'No Cytof' for x in toxicity.loc[:,'DATE_RECEPTION_CODED']]
toxicity['CTFAN'] = toxicity_ctfan
toxicity

for ipp in IPPs:
    subset = toxicity.loc[toxicity['IPP_CODED']==ipp,:].copy().reset_index().iloc[:,1:]
    row_index = [subset[x].first_valid_index() for x in subset.columns]
    row_index = [0 if x is None else x for x in row_index]
    toxicity_agg.loc[ipp,:] = [subset.iloc[row_index[x],x] for x in range(0,subset.shape[1])]

toxicity_agg = toxicity_agg.iloc[:,5:]
toxicity_agg = toxicity_agg.dropna(axis=0, how='all')
toxicity_agg = toxicity_agg.dropna(axis=1, how='all')
toxicity_agg

"""# **Onco**"""

onco = pd.read_excel('onco diagnostic.xlsx')
onco = onco.drop_duplicates('IPP_CODED',keep ='first')
onco.loc[:,'DATE_NAISSANCE_CODED'] = [int(x[6:10]) for x in onco.loc[:,'DATE_NAISSANCE_CODED']]
onco.loc[:,'DATE_ENTREE_SEJOUR_CODED'] = [int(x[6:10]) for x in onco.loc[:,'DATE_ENTREE_SEJOUR_CODED']]
onco.loc[:,'DATE_NAISSANCE_CODED'] = onco.loc[:,'DATE_ENTREE_SEJOUR_CODED'] - onco.loc[:,'DATE_NAISSANCE_CODED']
onco.index = onco['IPP_CODED']
onco = onco[['DATE_NAISSANCE_CODED','SEXE_CODE','CODE_UF_RESP_MEDICALE']]
onco.columns = ['Age','Sex','CODE_UF_RESP_MEDICALE']
onco.loc[onco['Sex']=='M','Sex'] = 1
onco.loc[onco['Sex']=='F','Sex'] = 0
onco



"""# **Aggregate**"""

[x for x in cytof_blood.index if x in cytof_lba.index and x in tox_lba.index and x in tox_blood.index]

cytof_blood_ = cytof_blood.copy()
cytof_blood_.columns = [x+' Blood' for x in cytof_blood.columns]
cytof_lba_ = cytof_lba.copy()
cytof_lba_.columns = [x+' LBA' for x in cytof_lba.columns]
tox_blood_ = tox_blood.copy()
tox_blood_.columns = [x+' Blood' for x in tox_blood.columns]
tox_lba_ = tox_lba.copy()
tox_lba_.columns = [x+' LBA' for x in tox_lba.columns]

samples = [x for x in cytof_blood.index if x in cytof_lba.index and x in tox_lba.index and x in tox_blood.index]
df = tox_lba_.join(cytof_lba_, on=tox_lba_.index, how='inner').iloc[:,1:]
#df = df.join(tox_blood_, on=df.index, how='inner').iloc[:,1:]
#df = df.join(tox_lba_, on=df.index, how='inner').iloc[:,1:]
df

ds_ = df.join(toxicity_agg, on=df.index, how='inner').iloc[:,1:]
ds_['Presentation'] = diag2['Presentation'].copy()
ds_['Presentation'] = ds_['Presentation'].fillna('Infection')
ds_['Presentation'][ds_['Presentation']=='COP'] = 0
ds_['Presentation'][ds_['Presentation']=='ILD'] = 1
ds_['Presentation'][ds_['Presentation']=='Sarcoid'] = 2
ds_['Presentation'][ds_['Presentation']=='Infection'] = 3
ds_['Label'] = diag2['Label']
ds_['Label'] = ds_['Label'].fillna(0)
ds_['Age'] = onco['DATE_NAISSANCE_CODED']
ds_['Age'] = ds_['Age'].fillna(ds_['Age'].median())
ds_['Sex'] = onco['SEXE_CODE']
ds_['Sex'] = ds_['Sex'].fillna('F')
ds_['Sex'][ds_['Sex']=='F'] = 0
ds_['Sex'][ds_['Sex']=='M'] = 1

ds_ = ds_.astype('float64')



"""Demo Analysis"""

cytof_blood

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
# import pandas_profiling
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from sklearn.feature_selection import chi2,f_classif
from sklearn.linear_model import LogisticRegressionCV
from sklearn.ensemble import RandomForestClassifier as RFC
from sklearn.ensemble import GradientBoostingClassifier as GBC

#from sklearn.metrics import plot_roc_curve
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import StratifiedKFold
import copy
import random
from sklearn.impute import SimpleImputer

import sklearn.metrics

# %matplotlib inline
# %config InlineBackend.figure_format='retina'

from sklearn.metrics import RocCurveDisplay

feature_cytof = [x for x in cytof_blood_.columns]+[x for x in cytof_lba_.columns]
feature_tox = [x for x in tox_blood_.columns]+[x for x in tox_lba_.columns]
feature_demo = ['Age','Sex']
feature_history = [x for x in diag.columns if x not in ['Label','Grade','Class']]

ds = df.join(diag, on=df.index, how='left').iloc[:,1:]
ds = ds.join(onco.iloc[:,:-1], on=ds.index, how='inner').iloc[:,1:]
ds = ds.fillna(ds.median())
ds

ds_ = ds.copy()

feature_cytof = [x for x in feature_cytof if x in ds_]
feature_tox = [x for x in feature_tox if x in ds_]
feature_demo = [x for x in feature_demo if x in ds_]
feature_history = [x for x in feature_history if x in ds_]

ds_['Label'][ds_['Label']>0] = 1

ds__= ds_[feature_cytof]
ds__= ds__.fillna(ds__.median())
ch_ = f_classif(ds__[feature_cytof], ds_['Label'],)
ch_ = np.concatenate([x[:, np.newaxis] for x in ch_], axis=1)
ch_ = pd.DataFrame(ch_, index=feature_cytof, columns=['F statistic','p'])
ch_ = ch_.sort_values('F statistic')

sig_cells = list(ch_.loc[ch_['p']<0.1,:].index)

ch_['count'] = ds__[feature_cytof].sum()/ds_.shape[0]
ch_['Cell'] = ch_.index
_, subplots = plt.subplots(2,
                           1,
                           figsize=(15, 10),
                           gridspec_kw={'height_ratios': [2, 1]},
                           sharex=True)
ch_.plot.bar('Cell',
             'F statistic',
             ax=subplots[0],
             grid=True,
             alpha=.7,
             ylabel='chi2',
             logy=True)
ax = plt.twinx(subplots[0])
ch_.plot.scatter('Cell', 'p', ax=ax, logy=True, color='red')
ax.grid(axis='y', linestyle=':')
ch_.plot.bar('Cell', 'count', ax=subplots[1], logy=True, grid=True)
subplots[-1].set_xlabel('Cell')
plt.suptitle('Presentation by Relative Cytof (2 Class)')

plt.tight_layout()
#plt.savefig('Pres_RelCytof.png',dpi=300)



ds__= ds_[feature_cytof+feature_tox+feature_demo].astype('float64')
ds__= ds__.fillna(ds__.median())
ch_ = f_classif(ds__[feature_cytof+feature_tox+feature_demo], ds_['Label'])
ch_ = np.concatenate([x[:, np.newaxis] for x in ch_], axis=1)
ch_ = pd.DataFrame(ch_, index=feature_cytof+feature_tox+feature_demo, columns=['F statistic','p'])
ch_=ch_.sort_values('F statistic')

sig_cytokines = list(ch_.loc[ch_['p']<0.1,:].index)

ch_['count'] = ds__[feature_cytof+feature_tox+feature_demo].sum()/ds_.shape[0]
ch_['Cytokine'] = ch_.index
_, subplots = plt.subplots(2,
                           1,
                           figsize=(15, 10),
                           gridspec_kw={'height_ratios': [2, 1]},
                           sharex=True)
ch_.plot.bar('Cytokine',
             'F statistic',
             ax=subplots[0],
             grid=True,
             alpha=.7,
             ylabel='chi2',
             logy=True)
ax = plt.twinx(subplots[0])
ch_.plot.scatter('Cytokine', 'p', ax=ax, logy=True, color='red')
ax.grid(axis='y', linestyle=':')
ch_.plot.bar('Cytokine', 'count', ax=subplots[1], logy=True, grid=True)
subplots[-1].set_xlabel('Cytokine')
plt.suptitle('Presentation by Absolute Cytof (2 Class)')

plt.tight_layout()
plt.savefig('Pres_Cytokine.png',dpi=300)

ch_ = chi2(ds_[feature_history], ds_['Class'])
ch_ = np.concatenate([x[:, np.newaxis] for x in ch_], axis=1)
ch_ = pd.DataFrame(ch_, index=feature_history, columns=['chi2','p'])

ch_=ch_.sort_values('chi2')
ch_['count'] = ds_[feature_history].sum()
ch_['ICD10'] = ch_.index
ch_ = ch_.iloc[-30:,:]
_, subplots = plt.subplots(2,
                           1,
                           figsize=(15, 22),
                           gridspec_kw={'height_ratios': [2, 1]},
                           sharex=True)
ch_.plot.bar('ICD10',
             'chi2',
             ax=subplots[0],
             grid=True,
             alpha=.7,
             ylabel='chi2',
             logy=True)
ax = plt.twinx(subplots[0])
ch_.plot.scatter('ICD10', 'p', ax=ax, logy=True, color='red')
# ax.set_ylim(1e-34,1)
ax.grid(axis='y', linestyle=':')
ch_.plot.bar('ICD10', 'count', ax=subplots[1], logy=True, grid=True)
subplots[-1].set_xlabel('ICD10')
plt.suptitle('Lung metastasis by top 30 primary cancers')
plt.tight_layout()
#plt.savefig('Chi_Cancers_top30.png',dpi=300)

ds[feature_history]

print(sig_cells)
print(sig_cytokines)

sig_ds = ds_[sig_cells+sig_cytokines+['Presentation']].astype('float64')
notsarco_mean = sig_ds.loc[sig_ds['Presentation']==0,:].mean()
notsarco_sd = sig_ds.loc[sig_ds['Presentation']==0,:].std()/2
ild_mean = sig_ds.loc[sig_ds['Presentation']=='ILD',:].mean()
ild_sd = sig_ds.loc[sig_ds['Presentation']=='ILD',:].std()/2
sar_mean = sig_ds.loc[sig_ds['Presentation']==1,:].mean()
sar_sd = sig_ds.loc[sig_ds['Presentation']==1,:].std()/2

notsarco_mean

notsarco_mean[:-1]

x - width/2

labels = sig_cells+sig_cytokines

x = np.arange(len(labels))  # the label locations
width = 0.35  # the width of the bars

fig, ax = plt.subplots()
fig.set_size_inches(15, 8)
rects1 = ax.bar(x - width/2, notsarco_mean[:-1], width/2, label='Not Sarcoid', yerr=notsarco_sd[:-1])
rects2 = ax.bar(x + width/2, sar_mean[:-1], width/2, label='Sarcoid', yerr=sar_sd[:-1])
#rects3 = ax.bar(x + width/2, sar_mean[:-1], width/3, label='Sarcoid', yerr=sar_sd[:-1])

# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_ylabel('Cell/Cytokine Abundance')
ax.set_title('Cell/Cytokine Abundance by Presentation')
#plt.xlabel(labels)
ax.set_xticks(x)
ax.set_xticklabels(labels, rotation = 90)
ax.legend()

ax.bar_label(rects1, padding=3)
ax.bar_label(rects2, padding=3)
#ax.bar_label(rects3, padding=3)

fig.tight_layout()

plt.savefig('Pres_BarSig.png', dpi=300)

plt.show()

random.seed(121)
class ModelObj:
    def __init__(self,model,x,y,i_train,i_test=None):
        self.model = copy.deepcopy(model)
        self.x_train = x.iloc[i_train]
        self.y_train = y.iloc[i_train]
        if i_test is not None:
            self.x_test = x.iloc[i_test]
            self.y_test = y.iloc[i_test]
        else:
            self.x_test=None
            self.y_test=None

    def fit(self):
        self.model.fit(self.x_train,self.y_train)
        self.p_train = self.model.predict_proba(self.x_train)
        if self.x_test is not None:
            self.p_test = self.model.predict_proba(self.x_test)
        return self

ds_

random.seed(121)
feature_cols =  list(feature_cytof)+list(feature_tox)+list(feature_demo)+list(feature_history)
rf = RFC(n_estimators=1000,n_jobs=-1,min_samples_leaf=0.01)
kf_ = StratifiedKFold(shuffle=True).split(ds_, ds_['Label'])
rf = [
    ModelObj(rf, ds_[feature_cols], ds_['Label'], i, j).fit()
    for i, j in kf_
]

_,subs=plt.subplots(int(np.ceil(len(rf)/2)),2,figsize=(15,10),sharex=False)
subs = subs.flatten()
for c_,r_ in enumerate(rf):
    ax=subs[c_]
    plt.sca(ax)
    RocCurveDisplay.from_estimator(r_.model,r_.x_train,r_.y_train,c='b',ax=ax)
    RocCurveDisplay.from_estimator(r_.model,r_.x_test,r_.y_test,c='b',linestyle='--',ax=ax)

    plt.plot([0,1],[0,1],':r')
    plt.grid()
    plt.xlim(0,1)
    plt.ylim(0,1)

ds_['Label']





"""# **Data Normalization**"""

for col in feature_cytof+feature_tox:
    ds_[col] = (ds_[col]-ds_[col].min())/(ds_[col].max()-ds_[col].min())

ds_ = ds_.dropna(axis=1)

ds_

"""# **PCA**"""

X = ds_[feature_cytof+feature_tox+feature_demo+feature_history]
y = ds_['Label']
y_ = y.copy()

y[y=='COP'] = 0
y[y=='ILD'] = 1
y[y=='Sarcoid'] = 1
y[y=='Infection'] = 0

from sklearn.decomposition import PCA

# Initialize PCA
pca = PCA(n_components=2)

# Apply PCA to your features
pca_result = pca.fit_transform(X)

# Visualize the reduced data
plt.scatter(pca_result[:, 0], pca_result[:, 1], c=y, cmap="viridis")
plt.title("PCA Visualization")
plt.xlabel("Principal Component 1")
plt.ylabel("Principal Component 2")
plt.colorbar(label="Diagnosis")
plt.show()





"""# **Patients Clustering**"""

from sklearn.cluster import KMeans

# Assuming X contains your feature data
k = 3  # Number of clusters

kmeans = KMeans(n_clusters=k, random_state=42)
labels = kmeans.fit_predict(X)

import matplotlib.pyplot as plt

# Assuming you have 2D PCA-transformed data
plt.scatter(pca_result[:, 0], pca_result[:, 1], c=labels, cmap='viridis')
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], marker='x', s=200, linewidths=3, color='r')
plt.title("K-means Clustering")
plt.xlabel("Principal Component 1")
plt.ylabel("Principal Component 2")
plt.show()

y[y==0] = 0
y[y==1] = 1
y[y==2] = 1
y[y==3] = 0

"""# **Feature Importance**"""

y[y=='Sarcoid'] = 1
y[y=='ILD'] = 1
y[y=='Infection'] = 0
y[y=='COP'] = 0
y = y.astype('float64')

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix

# Split data into features (X) and labels (y)
#X = ds_.drop(['L'], axis=1)
#y = ds_['Diagnosis']

# Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=42)

# Initialize and train the model
clf = RandomForestClassifier()
clf.fit(X_train, y_train)

# Make predictions
y_pred = clf.predict(X_test)

# Evaluate the model
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

# After training the model
feature_importances = clf.feature_importances_
sorted_indices = feature_importances.argsort()[::-1]  # Get indices sorted by importance

num_top_features = 20
top_feature_indices = sorted_indices[:num_top_features]
X_selected = X_train.iloc[:, top_feature_indices]
X_selected_test = X_test.iloc[:, top_feature_indices]

clf_selected = RandomForestClassifier()
clf_selected.fit(X_selected, y_train)

# Make predictions
y_pred = clf_selected.predict(X_selected_test)

# Evaluate the model
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'clf_selected' is your trained Random Forest model
# and 'X_selected' are the features you've selected

# Calculate feature importances from the model
feature_importances = clf_selected.feature_importances_

# Create a DataFrame to hold feature names and their importances
feature_importance_df = pd.DataFrame({'Feature': X_selected.columns, 'Importance': feature_importances})

# Sort features by importance in descending order
feature_importance_df = feature_importance_df.sort_values(by='Importance', ascending=False)

# Create a bar plot to visualize feature importances
plt.figure(figsize=(10, 6))
sns.barplot(x='Importance', y='Feature', data=feature_importance_df)
plt.title("Feature Importances")
plt.xlabel("Importance")
plt.ylabel("Feature")
plt.show()



"""# **Through Therapy**"""

cytof_clear

"""# **Doubloons**"""

